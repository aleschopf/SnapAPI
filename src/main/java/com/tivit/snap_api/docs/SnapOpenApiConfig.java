package com.tivit.snap_api.docs;

import com.tivit.snap_api.config.SnapApiProperties;
import com.tivit.snap_api.core.SnapRegistry;
import com.tivit.snap_api.core.SnapResourceMeta;
import com.tivit.snap_api.enums.Endpoint;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.Operation;
import io.swagger.v3.oas.models.PathItem;
import io.swagger.v3.oas.models.Paths;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.media.Content;
import io.swagger.v3.oas.models.media.MediaType;
import io.swagger.v3.oas.models.media.Schema;
import io.swagger.v3.oas.models.parameters.Parameter;
import io.swagger.v3.oas.models.parameters.RequestBody;
import io.swagger.v3.oas.models.responses.ApiResponse;
import io.swagger.v3.oas.models.responses.ApiResponses;
import jakarta.persistence.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springdoc.core.customizers.OpenApiCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Configuration
public class SnapOpenApiConfig {
    private static final Logger log = LoggerFactory.getLogger(SnapOpenApiConfig.class);

    private final ThreadLocal<Set<Class<?>>> processingClasses = ThreadLocal.withInitial(HashSet::new);
    private final Map<Class<?>, String> resolvedSchemas = new ConcurrentHashMap<>();

    private final SnapApiProperties snapApiProperties;

    public SnapOpenApiConfig(SnapApiProperties snapApiProperties) {
        this.snapApiProperties = snapApiProperties;
    }

    @Bean
    public OpenAPI snapOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("SnapREST API")
                        .description("API automatically generated by SnapREST")
                        .version("1.0"))
                .components(new Components());
    }

    @Bean
    public OpenApiCustomizer snapApiCustomizer() {
        return openApi -> {
            Paths paths = new Paths();
            log.debug("Starting documentation generation for {} resources", SnapRegistry.getAll().size());

            for (SnapResourceMeta meta : SnapRegistry.getAll()) {
                String path = normalizePath(meta.path());
                String tag = meta.entityClass().getSimpleName();
                log.debug("Processing resource: {} ({})", path, tag);

                PathItem pathItem = paths.containsKey(path) ? paths.get(path) : new PathItem();
                boolean pathModified = false;

                String pathWithId = path + "/{id}";
                PathItem pathItemWithId = paths.containsKey(pathWithId) ? paths.get(pathWithId) : new PathItem();
                boolean pathWithIdModified = false;

                if (meta.isEndpointEnabled(Endpoint.GET_ALL)) {
                    log.debug("Adding GET_ALL for {}", path);
                    pathItem.get(buildGetAllOperation(meta, tag));
                    pathModified = true;
                }

                if (meta.isEndpointEnabled(Endpoint.CREATE)) {
                    log.debug("Adding CREATE for {}", path);
                    pathItem.post(buildPostOperation(openApi, meta, tag));
                    pathModified = true;
                }

                if (meta.isEndpointEnabled(Endpoint.GET_BY_ID)) {
                    log.debug("Adding GET_BY_ID for {}", pathWithId);
                    pathItemWithId.get(buildGetByIdOperation(meta, tag));
                    pathWithIdModified = true;
                }

                if (meta.isEndpointEnabled(Endpoint.EDIT)) {
                    log.debug("Adding EDIT for {}", pathWithId);
                    pathItemWithId.put(buildPutOperation(openApi, meta, tag));
                    pathWithIdModified = true;
                }

                if (meta.isEndpointEnabled(Endpoint.DELETE)) {
                    log.debug("Adding DELETE for {}", pathWithId);
                    pathItemWithId.delete(buildDeleteOperation(meta, tag));
                    pathWithIdModified = true;
                }

                if (pathModified) {
                    paths.addPathItem(path, pathItem);
                }
                if (pathWithIdModified) {
                    paths.addPathItem(pathWithId, pathItemWithId);
                }
            }

            openApi.paths(paths);
            log.debug("Documentation generated with {} paths", paths.size());
        };
    }

    private Operation buildGetAllOperation(SnapResourceMeta meta, String tag) {
        return new Operation()
                .operationId("getAll" + tag)
                .tags(List.of(tag))
                .summary("List all " + tag)
                .description("Returns a paginated list of " + tag)
                .parameters(List.of(
                        new Parameter().name("page").in("query").description("Page number"),
                        new Parameter().name("size").in("query").description("Page size"),
                        new Parameter().name("sort").in("query").description("Sorting criteria")
                ))
                .responses(new ApiResponses()
                        .addApiResponse("200", new ApiResponse()
                                .description("List of " + tag + " returned successfully")
                                .content(new Content()
                                        .addMediaType("application/json", new MediaType()
                                                .schema(new Schema<>()
                                                        .$ref("#/components/schemas/Page_" + tag))))));
    }

    private Operation buildGetByIdOperation(SnapResourceMeta meta, String tag) {
        return new Operation()
                .operationId("getById" + tag)
                .tags(List.of(tag))
                .summary("Get " + tag + " by ID")
                .description("Returns a single " + tag + " by its identifier")
                .parameters(List.of(
                        new Parameter().name("id").in("path").required(true).description("ID of the " + tag)
                ))
                .responses(new ApiResponses()
                        .addApiResponse("200", new ApiResponse()
                                .description(tag + " found")
                                .content(new Content()
                                        .addMediaType("application/json", new MediaType()
                                                .schema(new Schema<>()
                                                        .$ref("#/components/schemas/" + tag))))));
    }

    private Operation buildPostOperation(OpenAPI openApi, SnapResourceMeta meta, String tag) {
        Schema<?> schema = resolveSchema(openApi, meta.entityClass());

        return new Operation()
                .operationId("create" + tag)
                .tags(List.of(tag))
                .summary("Create new " + tag)
                .description("Creates a new instance of " + tag)
                .requestBody(new RequestBody()
                        .description(tag + " to be created")
                        .content(new Content()
                                .addMediaType("application/json",
                                        new MediaType().schema(schema)))
                        .required(true))
                .responses(new ApiResponses()
                        .addApiResponse("201", new ApiResponse()
                                .description(tag + " created successfully")
                                .content(new Content()
                                        .addMediaType("application/json", new MediaType()
                                                .schema(schema)))));
    }

    private Operation buildPutOperation(OpenAPI openApi, SnapResourceMeta meta, String tag) {
        Schema<?> schema = resolveSchema(openApi, meta.entityClass());

        return new Operation()
                .operationId("edit" + tag)
                .tags(List.of(tag))
                .summary("Update " + tag)
                .description("Updates an existing " + tag)
                .parameters(List.of(
                        new Parameter().name("id").in("path").required(true).description("ID of the " + tag)
                ))
                .requestBody(new RequestBody()
                        .description(tag + " with updated data")
                        .content(new Content()
                                .addMediaType("application/json",
                                        new MediaType().schema(schema)))
                        .required(true))
                .responses(new ApiResponses()
                        .addApiResponse("200", new ApiResponse()
                                .description(tag + " updated successfully")
                                .content(new Content()
                                        .addMediaType("application/json", new MediaType()
                                                .schema(schema)))));
    }

    private Operation buildDeleteOperation(SnapResourceMeta meta, String tag) {
        return new Operation()
                .operationId("delete" + tag)
                .tags(List.of(tag))
                .summary("Remove " + tag)
                .description("Removes an existing " + tag)
                .parameters(List.of(
                        new Parameter().name("id").in("path").required(true).description("ID of the " + tag)
                ))
                .responses(new ApiResponses()
                        .addApiResponse("204", new ApiResponse()
                                .description(tag + " removed successfully"))
                        .addApiResponse("404", new ApiResponse()
                                .description(tag + " not found")));
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    private Schema resolveSchema(OpenAPI openApi, Class<?> entityClass) {
        String schemaName = entityClass.getSimpleName();

        if (processingClasses.get().contains(entityClass)) {
            return new Schema<>().$ref("#/components/schemas/" + schemaName);
        }

        if (resolvedSchemas.containsKey(entityClass)) {
            return new Schema<>().$ref("#/components/schemas/" + resolvedSchemas.get(entityClass));
        }

        processingClasses.get().add(entityClass);
        try {
            Map<String, Schema> schemas = openApi.getComponents().getSchemas();

            if (!schemas.containsKey(schemaName)) {
                Schema schema = new Schema<>()
                        .type("object")
                        .name(schemaName)
                        .title(schemaName);

                for (Field field : getAllFields(entityClass)) {
                    field.setAccessible(true);
                    String fieldName = field.getName();
                    Class<?> fieldType = field.getType();

                    if (field.isAnnotationPresent(ManyToOne.class) || field.isAnnotationPresent(OneToOne.class)) {
                        Schema refSchema = resolveSchema(openApi, fieldType);
                        schema.addProperty(fieldName, refSchema);
                    }
                    else if (field.isAnnotationPresent(OneToMany.class) || field.isAnnotationPresent(ManyToMany.class)) {
                        Class<?> genericType = getGenericType(field);
                        Schema itemsSchema = resolveSchema(openApi, genericType);
                        Schema arraySchema = new Schema<>()
                                .type("array")
                                .items(itemsSchema);
                        schema.addProperty(fieldName, arraySchema);
                    }
                    else if (field.isAnnotationPresent(Embedded.class)) {
                        Schema embeddedSchema = resolveSchema(openApi, fieldType);
                        schema.addProperty(fieldName, embeddedSchema);
                    }
                    else {
                        Schema fieldSchema = new Schema<>()
                                .type(getSchemaType(fieldType))
                                .example(getExampleValue(fieldType));
                        schema.addProperty(fieldName, fieldSchema);
                    }
                }

                openApi.getComponents().addSchemas(schemaName, schema);
                resolvedSchemas.put(entityClass, schemaName);

                String pageSchemaName = "Page_" + schemaName;
                Schema pageSchema = new Schema<>()
                        .type("object")
                        .name(pageSchemaName)
                        .title(pageSchemaName)
                        .addProperty("content", new Schema<>()
                                .type("array")
                                .items(new Schema<>().$ref("#/components/schemas/" + schemaName)))
                        .addProperty("totalElements", new Schema<>().type("integer"))
                        .addProperty("totalPages", new Schema<>().type("integer"))
                        .addProperty("size", new Schema<>().type("integer"))
                        .addProperty("number", new Schema<>().type("integer"));

                openApi.getComponents().addSchemas(pageSchemaName, pageSchema);
            }

            return new Schema<>().$ref("#/components/schemas/" + schemaName);
        } finally {
            processingClasses.get().remove(entityClass);
        }
    }

    private String getSchemaType(Class<?> fieldType) {
        if (fieldType.isEnum()) {
            return "string";
        }
        if (fieldType == Integer.class || fieldType == int.class) {
            return "integer";
        }
        if (fieldType == Long.class || fieldType == long.class) {
            return "integer";
        }
        if (fieldType == String.class) {
            return "string";
        }
        if (fieldType == Boolean.class || fieldType == boolean.class) {
            return "boolean";
        }
        if (fieldType == Date.class || fieldType == LocalDate.class || fieldType == LocalDateTime.class) {
            return "string";
        }
        if (fieldType == Double.class || fieldType == double.class) {
            return "number";
        }
        if (fieldType == Float.class || fieldType == float.class) {
            return "number";
        }
        return "string";
    }

    private String getExampleValue(Class<?> fieldType) {
        if (fieldType == Integer.class || fieldType == int.class) {
            return "0";
        }
        if (fieldType == Long.class || fieldType == long.class) {
            return "0";
        }
        if (fieldType == String.class) {
            return "example";
        }
        if (fieldType == Boolean.class || fieldType == boolean.class) {
            return "true";
        }
        if (fieldType == Date.class || fieldType == LocalDate.class || fieldType == LocalDateTime.class) {
            return "2025-04-14";
        }
        if (fieldType == Double.class || fieldType == double.class) {
            return "0.0";
        }
        if (fieldType == Float.class || fieldType == float.class) {
            return "0.0";
        }
        return "example";
    }

    private List<Field> getAllFields(Class<?> clazz) {
        List<Field> fields = new ArrayList<>();
        while (clazz != null) {
            fields.addAll(Arrays.asList(clazz.getDeclaredFields()));
            clazz = clazz.getSuperclass();
        }
        return fields;
    }

    private Class<?> getGenericType(Field field) {
        ParameterizedType type = (ParameterizedType) field.getGenericType();
        return (Class<?>) type.getActualTypeArguments()[0];
    }

    private String normalizePath(String path) {
        return path.startsWith("/") ? path : "/" + path;
    }
}
